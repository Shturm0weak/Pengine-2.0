#version 450

layout(set = 0, binding = 0, r8) uniform writeonly image2D outColor;

layout(set = 0, binding = 1) uniform SSAO
{
    vec4 samples[64];
    int kernelSize;
    int noiseSize;
    float radius;
    float bias;
    float aoScale;
    vec2 viewportScale;
};

#include "Shaders/Includes/Camera.h"

layout(set = 1, binding = 0) uniform GlobalBuffer
{
    Camera camera;
};

layout(set = 0, binding = 2) uniform sampler2D depthTexture;
layout(set = 0, binding = 3) uniform sampler2D normalTexture;
layout(set = 0, binding = 4) uniform sampler2D noiseTexture;

//shared vec3 positionSharedData [16 * 16];

vec2 noiseScale = vec2((camera.viewportSize.x * viewportScale.x) / noiseSize, (camera.viewportSize.y * viewportScale.y) / noiseSize);
vec2 ssaoSize = camera.viewportSize * viewportScale;

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
void main()
{
	ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = (vec2(pixelCoord) + vec2(0.5f)) / ssaoSize;
	vec2 screenPosition = uv * 2.0f - 1.0f;
	uv.y = 1.0f - uv.y;

	vec2 viewRay;
	viewRay.x = -screenPosition.x * camera.aspectRatio * camera.tanHalfFOV;
    viewRay.y = -screenPosition.y * camera.tanHalfFOV;

    vec3 positionViewSpace = CalculatePositionFromDepth(
        texture(depthTexture, uv).x,
        camera.projectionMat4,
        viewRay);

	vec3 normalViewSpace = OctDecode(texture(normalTexture, uv).xy);
    vec3 randomVector = normalize(texture(noiseTexture, uv * noiseScale).xyz);
    vec3 tangentViewSpace = normalize(randomVector - normalViewSpace * dot(randomVector, normalViewSpace));
    vec3 bitangentViewSpace = normalize(cross(normalViewSpace, tangentViewSpace));
    mat3 TBN = mat3(tangentViewSpace, bitangentViewSpace, normalViewSpace);

    float occlusion = 0.0f;
    for (int i = 0; i < kernelSize; ++i)
    {
        vec3 currentSample = TBN * samples[i].xyz;
        currentSample = positionViewSpace + currentSample * radius;

        vec4 offset = vec4(currentSample, 1.0f);
        offset = camera.projectionMat4 * offset;
        offset.xyz /= offset.w;
        offset.xyz = offset.xyz * 0.5f + 0.5f;
		//offset.y = 1.0f - offset.y;

		float sampleDepth = 0.0f;
        offset.y = 1.0f - offset.y;
        sampleDepth = CalculatePositionFromDepth(
            texture(depthTexture, offset.xy).x,
            camera.projectionMat4,
            viewRay).z;

        float rangeCheck = 1.0f - smoothstep(0.0f, 1.0f, abs(positionViewSpace.z - sampleDepth) / radius);
        occlusion += (sampleDepth >= currentSample.z + bias ? 1.0f : 0.0f) * rangeCheck;
    }
    occlusion = 1.0f - (occlusion / float(kernelSize));
    occlusion = pow(occlusion, aoScale);

	pixelCoord.y = int(ssaoSize.y) - pixelCoord.y;
    imageStore(outColor, pixelCoord, vec4(occlusion));
}
