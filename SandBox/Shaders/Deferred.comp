#version 450

layout(set = 1, binding = 0) uniform sampler2D albedoTexture;
layout(set = 1, binding = 1) uniform sampler2D normalTexture;
layout(set = 1, binding = 2) uniform sampler2D shadingTexture;
layout(set = 1, binding = 3) uniform sampler2D depthTexture;
layout(set = 1, binding = 4) uniform sampler2D ssaoTexture;
layout(set = 1, binding = 5) uniform sampler2D sssTexture;
layout(set = 1, binding = 6) uniform sampler2DArray CSMTexture;
layout(set = 1, binding = 7) uniform sampler2D pointLightShadowMapTexture;
layout(set = 1, binding = 8) uniform sampler2D spotLightShadowMapTexture;

#include "Shaders/Includes/Camera.h"
#include "Shaders/Includes/IsBrightPixel.h"
#include "Shaders/Includes/DirectionalLight.h"
#include "Shaders/Includes/PointLight.h"
#include "Shaders/Includes/SpotLight.h"
#include "Shaders/Includes/CSM.h"
#include "Shaders/Includes/SSS.h"

layout(set = 0, binding = 0) uniform GlobalBuffer
{
	Camera camera;
};

layout(set = 2, binding = 0) uniform Lights
{
	PointLight pointLights[32];
	int pointLightsCount;

	SpotLight spotLights[32];
	int spotLightsCount;

	DirectionalLight directionalLight;
	int hasDirectionalLight;

	float brightnessThreshold;

	CSM csm;

	PointLightShadows pointLightShadows;
    SpotLightShadows spotLightShadows;

    SSS sss;
};

layout(set = 3, binding = 0, r11f_g11f_b10f) uniform writeonly image2D outColor;
layout(set = 3, binding = 1, r11f_g11f_b10f) uniform image2D outEmissive;

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
void main()
{
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = (vec2(pixelCoord) + vec2(0.5f)) / camera.viewportSize;
	vec2 screenPosition = uv * 2.0f - 1.0f;
	uv.y = 1.0f - uv.y;

	vec2 viewRay;
	viewRay.x = -screenPosition.x * camera.aspectRatio * camera.tanHalfFOV;
    viewRay.y = -screenPosition.y * camera.tanHalfFOV;

	vec3 albedoColor = texture(albedoTexture, uv).xyz;
	vec4 shading = texture(shadingTexture, uv);

	vec3 normalViewSpace = OctDecode(texture(normalTexture, uv).xy);
	vec3 ssao = vec3(texture(ssaoTexture, uv).r);

	vec3 result = vec3(0.0f);

	if (shading.a <= 0.0f)
	{
		result = albedoColor;
	}
	else
	{
		vec3 positionViewSpace = CalculatePositionFromDepth(
			texture(depthTexture, uv).x,
			camera.projectionMat4,
			viewRay);

		vec3 positionWorldSpace = (camera.inverseViewMat4 * vec4(positionViewSpace, 1.0f)).xyz;
		vec3 basicReflectivity = mix(vec3(0.05), albedoColor, shading.x);
		vec3 viewDirectionViewSpace = normalize(-positionViewSpace);

		if (hasDirectionalLight == 1)
		{
			vec3 shadow = vec3(0.0f);
			if (csm.isEnabled == 1)
			{
				shadow = CalculateCSM(
					CSMTexture,
					csm,
					abs(positionViewSpace.z),
					positionWorldSpace,
					normalViewSpace,
					directionalLight.directionViewSpace);
			}

			shadow += vec3(texture(sssTexture, uv).r);
			shadow = clamp(shadow, vec3(0.0f), vec3(1.0f));

			result += CalculateDirectionalLight(
				directionalLight,
				viewDirectionViewSpace,
				basicReflectivity,
				normalViewSpace,
				albedoColor,
				shading.x,
				shading.y,
				shading.z,
				shadow,
				ssao);
		}

		for (int i = 0; i < pointLightsCount; i++)
		{
			PointLight pointLight = pointLights[i];
			vec3 toLightWorldSpace = pointLight.positionWorldSpace - positionWorldSpace;
        	float distanceToPoint = length(toLightWorldSpace);
			if (distanceToPoint < pointLight.radius)
			{
				float shadow = 0.0f;
				if (pointLightShadows.isEnabled == 1 && pointLight.shadowMapIndex > -1)
				{
					shadow = CalculatePointLightShadow(
						pointLightShadowMapTexture,
						pointLight,
						pointLightShadows,
						toLightWorldSpace,
						distanceToPoint);

					if (pointLight.castSSS == 1)
					{
						vec3 toLightViewSpace = pointLight.positionViewSpace - positionViewSpace;
						shadow += CalculateScreenSpaceShadows(
							depthTexture,
							positionViewSpace,
							normalize(toLightViewSpace),
							viewRay,
							camera.projectionMat4,
							sss).r;

						shadow = clamp(shadow, 0.0f, 1.0f);
					}
				}

				result += CalculatePointLight(
					pointLight,
					viewDirectionViewSpace,
					positionViewSpace,
					basicReflectivity,
					normalViewSpace,
					albedoColor,
					shading.x,
					shading.y,
					shading.z,
					shadow);
			}
		}

		for (int i = 0; i < spotLightsCount; i++)
		{
			SpotLight spotLight = spotLights[i];
			vec3 toLightWorldSpace = spotLight.positionWorldSpace - positionWorldSpace;
        	float distanceToPoint = length(toLightWorldSpace);
			if (distanceToPoint < spotLight.radius)
			{
				float shadow = 0.0f;
				if (spotLightShadows.isEnabled == 1 && spotLight.shadowMapIndex > -1)
				{
					shadow = CalculateSpotLightShadow(
						spotLightShadowMapTexture,
						spotLight,
						spotLightShadows,
						positionWorldSpace,
						positionViewSpace,
						distanceToPoint);

					if (spotLight.castSSS == 1)
					{
						vec3 toLightViewSpace = spotLight.positionViewSpace - positionViewSpace;
						shadow += CalculateScreenSpaceShadows(
							depthTexture,
							positionViewSpace,
							normalize(toLightViewSpace),
							viewRay,
							camera.projectionMat4,
							sss).r;

						shadow = clamp(shadow, 0.0f, 1.0f);
					}
				}
				
				result += CalculateSpotLight(
					spotLight,
					viewDirectionViewSpace,
					positionViewSpace,
					basicReflectivity,
					normalViewSpace,
					albedoColor,
					shading.x,
					shading.y,
					shading.z,
					shadow);
			}
		}
	}

	pixelCoord.y = int(camera.viewportSize.y) - pixelCoord.y;

    vec4 emissive = vec4(IsBrightPixel(result, brightnessThreshold), 1.0f);
    emissive += imageLoad(outEmissive, pixelCoord);
    imageStore(outEmissive, pixelCoord, emissive);
    
    imageStore(outColor, pixelCoord, vec4(result, 1.0f));
}
